#!/usr/bin/env python3
"""
Test completo para Context Builder refactorizado con function calling.

Testa:
1. Clasificaci√≥n QUESTION vs INFORMATION
2. Funciones: summary(), show_context(), clear_context()
3. Extracci√≥n de informaci√≥n
4. Flujo completo
5. Manejo de errores
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import List

# Setup b√°sico
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Importar el servicio refactorizado
from app.services.context_builder import (
    ContextBuilderService, 
    ContextMessage, 
    CONTEXT_FUNCTIONS
)

async def test_basic_functionality():
    """Test b√°sico de inicializaci√≥n y configuraci√≥n."""
    print("üß™ Test 1: Configuraci√≥n b√°sica")
    
    service = ContextBuilderService()
    
    # Verificar configuraci√≥n actualizada
    assert service.temperature == 0.2, f"‚ùå Temperature: esperado 0.2, obtenido {service.temperature}"
    assert service.max_tokens == 250, f"‚ùå Max tokens: esperado 250, obtenido {service.max_tokens}"
    assert service.seed == 42, f"‚ùå Seed: esperado 42, obtenido {service.seed}"
    
    # Verificar funciones definidas
    assert len(CONTEXT_FUNCTIONS) == 3, f"‚ùå Funciones: esperado 3, obtenido {len(CONTEXT_FUNCTIONS)}"
    function_names = [func["name"] for func in CONTEXT_FUNCTIONS]
    expected_names = ["summary", "show_context", "clear_context"]
    for name in expected_names:
        assert name in function_names, f"‚ùå Funci√≥n {name} no encontrada"
    
    print("‚úÖ Configuraci√≥n b√°sica correcta")

async def test_message_classification():
    """Test de clasificaci√≥n de mensajes."""
    print("\nüß™ Test 2: Clasificaci√≥n de mensajes")
    
    service = ContextBuilderService()
    
    # Test cases para clasificaci√≥n
    test_cases = [
        ("¬øC√≥mo puedo mejorar mi marketing?", "question"),
        ("Tengo una startup de software dental", "information"),
        ("Necesito 50 clientes en 3 meses con presupuesto de $2000", "information"),
        ("¬øCu√°l es la mejor estrategia?", "question"),
        ("Mi empresa est√° en M√©xico y Colombia", "information"),
        ("¬øQu√© me recomiendas para crecer?", "question")
    ]
    
    for message, expected_type in test_cases:
        try:
            message_type, confidence = await service._smart_classify(message)
            print(f"üìù '{message[:30]}...' ‚Üí {message_type} (confianza: {confidence:.2f})")
            
            # No es cr√≠tico que coincida exactamente, pero debe ser razonable
            if confidence > 0.7:
                assert message_type == expected_type, f"‚ùå Clasificaci√≥n incorrecta para: {message}"
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error clasificando '{message}': {e}")
    
    print("‚úÖ Clasificaci√≥n de mensajes funcional")

async def test_function_execution():
    """Test de ejecuci√≥n de funciones."""
    print("\nüß™ Test 3: Ejecuci√≥n de funciones")
    
    service = ContextBuilderService()
    
    # Mock function_call object
    class MockFunctionCall:
        def __init__(self, name, arguments="{}"):
            self.name = name
            self.arguments = arguments
    
    # Test context vac√≠o
    context = ""
    
    # Test show_context con contexto vac√≠o
    result, updated_context = service._execute_function(
        MockFunctionCall("show_context"), context
    )
    print(f"üìã show_context (vac√≠o): {result[:50]}...")
    assert "No hay contexto acumulado" in result
    assert updated_context == ""
    
    # Test con contexto
    test_context = "Startup de software dental en M√©xico. Objetivo: 50 clientes. Presupuesto: $2000/mes."
    
    # Test show_context con contexto
    result, updated_context = service._execute_function(
        MockFunctionCall("show_context"), test_context
    )
    print(f"üìã show_context (con datos): {result[:50]}...")
    assert "palabras" in result and "caracteres" in result
    assert updated_context == test_context
    
    # Test summary
    result, updated_context = service._execute_function(
        MockFunctionCall("summary", '{"max_sentences": 1}'), test_context
    )
    print(f"üìã summary: {result[:50]}...")
    assert "Resumen del contexto" in result
    assert updated_context == test_context  # No debe cambiar
    
    # Test clear_context
    result, updated_context = service._execute_function(
        MockFunctionCall("clear_context"), test_context
    )
    print(f"üóëÔ∏è clear_context: {result[:50]}...")
    assert "Contexto borrado" in result
    assert updated_context == ""  # Debe vaciarse
    
    print("‚úÖ Ejecuci√≥n de funciones correcta")

async def test_information_extraction():
    """Test de extracci√≥n de informaci√≥n."""
    print("\nüß™ Test 4: Extracci√≥n de informaci√≥n")
    
    service = ContextBuilderService()
    
    # Test de extracci√≥n heur√≠stica (fallback)
    message = "Tengo una startup con 25 empleados, presupuesto de $5000 mensuales"
    context = ""
    
    try:
        extracted = await service._extract_information_from_message(message, context)
        print(f"üìä Informaci√≥n extra√≠da: {extracted}")
        
        # Verificar que extrajo algo √∫til
        assert len(extracted) > 0, "‚ùå No se extrajo informaci√≥n"
        
    except Exception as e:
        # Si falla el LLM, probar heur√≠stica
        print(f"‚ö†Ô∏è LLM extraction fall√≥, probando heur√≠stica: {e}")
        extracted = service._extract_info_heuristic(message, context)
        print(f"üìä Informaci√≥n extra√≠da (heur√≠stica): {extracted}")
        assert len(extracted) > 0, "‚ùå Heur√≠stica no extrajo informaci√≥n"
    
    print("‚úÖ Extracci√≥n de informaci√≥n funcional")

async def test_full_conversation_flow():
    """Test del flujo completo de conversaci√≥n."""
    print("\nüß™ Test 5: Flujo completo de conversaci√≥n")
    
    service = ContextBuilderService()
    conversation_history = []
    current_context = ""
    
    # Simulaci√≥n de conversaci√≥n completa
    messages = [
        "Tengo una startup de software para cl√≠nicas dentales",
        "Estamos en fase beta con 10 clientes piloto", 
        "Nuestro objetivo es llegar a 100 clientes en 6 meses",
        "¬øC√≥mo puedo mejorar mi estrategia de marketing?"
    ]
    
    for i, message in enumerate(messages):
        print(f"\nüí¨ Mensaje {i+1}: '{message}'")
        
        try:
            response = await service.process_user_message(
                user_message=message,
                conversation_history=conversation_history,
                current_context=current_context
            )
            
            print(f"ü§ñ Respuesta: {response.ai_response[:100]}...")
            print(f"üìù Tipo: {response.message_type}")
            print(f"üìä Contexto actual: {len(response.accumulated_context)} chars")
            print(f"üí° Sugerencias: {response.suggestions[:2]}")
            
            # Actualizar para siguiente iteraci√≥n
            current_context = response.accumulated_context
            conversation_history.append(ContextMessage(
                role="user",
                content=message,
                timestamp=datetime.now()
            ))
            conversation_history.append(ContextMessage(
                role="assistant", 
                content=response.ai_response,
                timestamp=datetime.now(),
                message_type=response.message_type
            ))
            
            # Verificaciones b√°sicas
            assert response.ai_response is not None, "‚ùå Sin respuesta AI"
            assert response.message_type in ["question", "information", "command_result"], f"‚ùå Tipo inv√°lido: {response.message_type}"
            assert isinstance(response.suggestions, list), "‚ùå Sugerencias no es lista"
            assert response.context_elements_count >= 0, "‚ùå Contador de elementos negativo"
            
        except Exception as e:
            print(f"‚ùå Error en mensaje {i+1}: {e}")
            # No fallar completamente, continuar con el test
    
    print(f"\n‚úÖ Flujo completo procesado - Contexto final: {len(current_context)} caracteres")

async def test_function_calling_simulation():
    """Test simulado de function calling."""
    print("\nüß™ Test 6: Simulaci√≥n de function calling")
    
    service = ContextBuilderService()
    
    # Simular que GPT-3.5 retorn√≥ una function_call
    class MockChoice:
        def __init__(self, function_call=None, content=None):
            self.message = MockMessage(function_call, content)
    
    class MockMessage:
        def __init__(self, function_call=None, content=None):
            self.function_call = function_call
            self.content = content
    
    class MockFunctionCall:
        def __init__(self, name, arguments="{}"):
            self.name = name
            self.arguments = arguments
    
    # Test con function_call
    test_context = "Startup de software dental en M√©xico. Presupuesto: $2000."
    
    # Simular ejecuci√≥n de summary
    function_call = MockFunctionCall("summary", '{"max_sentences": 2}')
    result, updated_context = service._execute_function(function_call, test_context)
    
    print(f"üîß Function call simulado - summary:")
    print(f"   Resultado: {result[:80]}...")
    print(f"   Contexto preservado: {len(updated_context)} chars")
    
    assert "Resumen del contexto" in result
    assert updated_context == test_context
    
    print("‚úÖ Function calling simulado correctamente")

async def test_error_handling():
    """Test de manejo de errores."""
    print("\nüß™ Test 7: Manejo de errores")
    
    service = ContextBuilderService()
    
    # Test funci√≥n inexistente
    class MockFunctionCall:
        def __init__(self, name, arguments="{}"):
            self.name = name
            self.arguments = arguments
    
    result, updated_context = service._execute_function(
        MockFunctionCall("nonexistent_function"), "test context"
    )
    
    print(f"üö´ Funci√≥n inexistente: {result[:50]}...")
    assert "Error" in result and "no reconocida" in result
    
    # Test argumentos JSON inv√°lidos
    result, updated_context = service._execute_function(
        MockFunctionCall("summary", 'invalid json'), "test context"
    )
    
    print(f"üö´ JSON inv√°lido manejado correctamente")
    assert "Resumen del contexto" in result  # Debe usar argumentos por defecto
    
    print("‚úÖ Manejo de errores funcional")

async def run_all_tests():
    """Ejecuta todos los tests."""
    print("üöÄ Iniciando tests del Context Builder refactorizado...\n")
    
    tests = [
        test_basic_functionality,
        test_message_classification,
        test_function_execution,
        test_information_extraction,
        test_full_conversation_flow,
        test_function_calling_simulation,
        test_error_handling
    ]
    
    passed = 0
    failed = 0
    
    for test in tests:
        try:
            await test()
            passed += 1
        except Exception as e:
            print(f"‚ùå Test fall√≥: {test.__name__}")
            print(f"   Error: {e}")
            failed += 1
    
    print(f"\nüìä Resultados finales:")
    print(f"‚úÖ Tests pasados: {passed}")
    print(f"‚ùå Tests fallidos: {failed}")
    print(f"üéØ Total: {passed + failed}")
    
    if failed == 0:
        print("\nüéâ ¬°Todos los tests pasaron! La refactorizaci√≥n est√° funcionando correctamente.")
    else:
        print(f"\n‚ö†Ô∏è {failed} tests fallaron. Revisar implementaci√≥n.")
    
    return failed == 0

if __name__ == "__main__":
    success = asyncio.run(run_all_tests())
    exit(0 if success else 1) 